#
# Pure Fusion API
# Pure Fusion is fully API-driven. Most APIs which change the system (POST, PATCH, DELETE) return an Operation in status ""Pending"" or ""Running"". You can poll (GET) the operation to check its status, waiting for it to change to ""Succeeded"" or ""Failed"". 
# Version: 1.1
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

(Provider) Creates a Network Interface Group.

.DESCRIPTION

No description available.

.PARAMETER RegionName
The Region name

.PARAMETER AvailabilityZoneName
The Availability Zone name

.PARAMETER NetworkInterfaceGroupPost
No description available.

.PARAMETER XRequestID
The Request ID supplied with the request, used to perform operations idempotently.

.PARAMETER Authorization
Access token (in JWT format) required to use any API endpoint.

.PARAMETER XCorrelationID
The Correlation ID provided will be added to log messages and can be used for support. The same Correlation ID may be used for separate requests, to track a higher level workflow.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Operation
#>
function New-PSFNetworkInterfaceGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${RegionName},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AvailabilityZoneName},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${NetworkInterfaceGroupPost},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XRequestID},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Authorization},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XCorrelationID},
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: New-PSFNetworkInterfaceGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-PSFConfiguration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')

        $LocalVarUri = '/regions/{region_name}/availability-zones/{availability_zone_name}/network-interface-groups'
        if (!$RegionName) {
            throw "Error! The required parameter `RegionName` missing when calling createNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{region_name}', [System.Web.HTTPUtility]::UrlEncode($RegionName))
        if (!$AvailabilityZoneName) {
            throw "Error! The required parameter `AvailabilityZoneName` missing when calling createNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{availability_zone_name}', [System.Web.HTTPUtility]::UrlEncode($AvailabilityZoneName))

        if ($XRequestID) {
            $LocalVarHeaderParameters['X-Request-ID'] = $XRequestID
        }

        if ($Authorization) {
            $LocalVarHeaderParameters['Authorization'] = $Authorization
        }

        if ($XCorrelationID) {
            $LocalVarHeaderParameters['X-Correlation-ID'] = $XCorrelationID
        }

        if (!$NetworkInterfaceGroupPost) {
            throw "Error! The required parameter `NetworkInterfaceGroupPost` missing when calling createNetworkInterfaceGroup."
        }

        $LocalVarBodyParameter = $NetworkInterfaceGroupPost | ConvertTo-Json -Depth 100

        if ($Configuration["AccessToken"]) {
            $LocalVarHeaderParameters['Authorization'] = "Bearer " + $Configuration["AccessToken"]
            Write-Verbose ("Using Bearer authentication in {0}" -f $MyInvocation.MyCommand)
        }


        $LocalVarResult = Invoke-PSFApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Operation" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

(Provider) Deletes a specific Network Interface Group.

.DESCRIPTION

No description available.

.PARAMETER RegionName
The Region name

.PARAMETER AvailabilityZoneName
The Availability Zone name

.PARAMETER NetworkInterfaceGroupName
(Provider) The Network Interface Group name

.PARAMETER XRequestID
The Request ID supplied with the request, used to perform operations idempotently.

.PARAMETER Authorization
Access token (in JWT format) required to use any API endpoint.

.PARAMETER XCorrelationID
The Correlation ID provided will be added to log messages and can be used for support. The same Correlation ID may be used for separate requests, to track a higher level workflow.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Operation
#>
function Remove-PSFNetworkInterfaceGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${RegionName},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AvailabilityZoneName},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${NetworkInterfaceGroupName},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XRequestID},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Authorization},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XCorrelationID},
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Remove-PSFNetworkInterfaceGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-PSFConfiguration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        $LocalVarUri = '/regions/{region_name}/availability-zones/{availability_zone_name}/network-interface-groups/{network_interface_group_name}'
        if (!$RegionName) {
            throw "Error! The required parameter `RegionName` missing when calling deleteNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{region_name}', [System.Web.HTTPUtility]::UrlEncode($RegionName))
        if (!$AvailabilityZoneName) {
            throw "Error! The required parameter `AvailabilityZoneName` missing when calling deleteNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{availability_zone_name}', [System.Web.HTTPUtility]::UrlEncode($AvailabilityZoneName))
        if (!$NetworkInterfaceGroupName) {
            throw "Error! The required parameter `NetworkInterfaceGroupName` missing when calling deleteNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{network_interface_group_name}', [System.Web.HTTPUtility]::UrlEncode($NetworkInterfaceGroupName))

        if ($XRequestID) {
            $LocalVarHeaderParameters['X-Request-ID'] = $XRequestID
        }

        if ($Authorization) {
            $LocalVarHeaderParameters['Authorization'] = $Authorization
        }

        if ($XCorrelationID) {
            $LocalVarHeaderParameters['X-Correlation-ID'] = $XCorrelationID
        }

        if ($Configuration["AccessToken"]) {
            $LocalVarHeaderParameters['Authorization'] = "Bearer " + $Configuration["AccessToken"]
            Write-Verbose ("Using Bearer authentication in {0}" -f $MyInvocation.MyCommand)
        }


        $LocalVarResult = Invoke-PSFApiClient -Method 'DELETE' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Operation" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

(Provider) Gets a specific Network Interface Group.

.DESCRIPTION

No description available.

.PARAMETER RegionName
The Region name

.PARAMETER AvailabilityZoneName
The Availability Zone name

.PARAMETER NetworkInterfaceGroupName
(Provider) The Network Interface Group name

.PARAMETER XRequestID
The Request ID supplied with the request, used to perform operations idempotently.

.PARAMETER Authorization
Access token (in JWT format) required to use any API endpoint.

.PARAMETER XCorrelationID
The Correlation ID provided will be added to log messages and can be used for support. The same Correlation ID may be used for separate requests, to track a higher level workflow.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

NetworkInterfaceGroup
#>
function Get-PSFNetworkInterfaceGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${RegionName},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AvailabilityZoneName},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${NetworkInterfaceGroupName},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XRequestID},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Authorization},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XCorrelationID},
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-PSFNetworkInterfaceGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-PSFConfiguration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        $LocalVarUri = '/regions/{region_name}/availability-zones/{availability_zone_name}/network-interface-groups/{network_interface_group_name}'
        if (!$RegionName) {
            throw "Error! The required parameter `RegionName` missing when calling getNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{region_name}', [System.Web.HTTPUtility]::UrlEncode($RegionName))
        if (!$AvailabilityZoneName) {
            throw "Error! The required parameter `AvailabilityZoneName` missing when calling getNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{availability_zone_name}', [System.Web.HTTPUtility]::UrlEncode($AvailabilityZoneName))
        if (!$NetworkInterfaceGroupName) {
            throw "Error! The required parameter `NetworkInterfaceGroupName` missing when calling getNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{network_interface_group_name}', [System.Web.HTTPUtility]::UrlEncode($NetworkInterfaceGroupName))

        if ($XRequestID) {
            $LocalVarHeaderParameters['X-Request-ID'] = $XRequestID
        }

        if ($Authorization) {
            $LocalVarHeaderParameters['Authorization'] = $Authorization
        }

        if ($XCorrelationID) {
            $LocalVarHeaderParameters['X-Correlation-ID'] = $XCorrelationID
        }

        if ($Configuration["AccessToken"]) {
            $LocalVarHeaderParameters['Authorization'] = "Bearer " + $Configuration["AccessToken"]
            Write-Verbose ("Using Bearer authentication in {0}" -f $MyInvocation.MyCommand)
        }


        $LocalVarResult = Invoke-PSFApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "NetworkInterfaceGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

(Provider) Gets a specific Network Interface Group.

.DESCRIPTION

No description available.

.PARAMETER NetworkInterfaceGroupId
(Provider) The Network Interface Group ID

.PARAMETER XRequestID
The Request ID supplied with the request, used to perform operations idempotently.

.PARAMETER Authorization
Access token (in JWT format) required to use any API endpoint.

.PARAMETER XCorrelationID
The Correlation ID provided will be added to log messages and can be used for support. The same Correlation ID may be used for separate requests, to track a higher level workflow.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

NetworkInterfaceGroup
#>
function Get-PSFNetworkInterfaceGroupById {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${NetworkInterfaceGroupId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XRequestID},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Authorization},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XCorrelationID},
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-PSFNetworkInterfaceGroupById' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-PSFConfiguration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        $LocalVarUri = '/resources/network-interface-groups/{network_interface_group_id}'
        if (!$NetworkInterfaceGroupId) {
            throw "Error! The required parameter `NetworkInterfaceGroupId` missing when calling getNetworkInterfaceGroupById."
        }
        $LocalVarUri = $LocalVarUri.replace('{network_interface_group_id}', [System.Web.HTTPUtility]::UrlEncode($NetworkInterfaceGroupId))

        if ($XRequestID) {
            $LocalVarHeaderParameters['X-Request-ID'] = $XRequestID
        }

        if ($Authorization) {
            $LocalVarHeaderParameters['Authorization'] = $Authorization
        }

        if ($XCorrelationID) {
            $LocalVarHeaderParameters['X-Correlation-ID'] = $XCorrelationID
        }

        if ($Configuration["AccessToken"]) {
            $LocalVarHeaderParameters['Authorization'] = "Bearer " + $Configuration["AccessToken"]
            Write-Verbose ("Using Bearer authentication in {0}" -f $MyInvocation.MyCommand)
        }


        $LocalVarResult = Invoke-PSFApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "NetworkInterfaceGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

(Provider) Gets a list of all Network Interface Groups.

.DESCRIPTION

No description available.

.PARAMETER RegionName
The Region name

.PARAMETER AvailabilityZoneName
The Availability Zone name

.PARAMETER XRequestID
The Request ID supplied with the request, used to perform operations idempotently.

.PARAMETER Authorization
Access token (in JWT format) required to use any API endpoint.

.PARAMETER XCorrelationID
The Correlation ID provided will be added to log messages and can be used for support. The same Correlation ID may be used for separate requests, to track a higher level workflow.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

NetworkInterfaceGroupList
#>
function Invoke-PSFListNetworkInterfaceGroups {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${RegionName},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AvailabilityZoneName},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XRequestID},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Authorization},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XCorrelationID},
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-PSFListNetworkInterfaceGroups' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-PSFConfiguration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        $LocalVarUri = '/regions/{region_name}/availability-zones/{availability_zone_name}/network-interface-groups'
        if (!$RegionName) {
            throw "Error! The required parameter `RegionName` missing when calling listNetworkInterfaceGroups."
        }
        $LocalVarUri = $LocalVarUri.replace('{region_name}', [System.Web.HTTPUtility]::UrlEncode($RegionName))
        if (!$AvailabilityZoneName) {
            throw "Error! The required parameter `AvailabilityZoneName` missing when calling listNetworkInterfaceGroups."
        }
        $LocalVarUri = $LocalVarUri.replace('{availability_zone_name}', [System.Web.HTTPUtility]::UrlEncode($AvailabilityZoneName))

        if ($XRequestID) {
            $LocalVarHeaderParameters['X-Request-ID'] = $XRequestID
        }

        if ($Authorization) {
            $LocalVarHeaderParameters['Authorization'] = $Authorization
        }

        if ($XCorrelationID) {
            $LocalVarHeaderParameters['X-Correlation-ID'] = $XCorrelationID
        }

        if ($Configuration["AccessToken"]) {
            $LocalVarHeaderParameters['Authorization'] = "Bearer " + $Configuration["AccessToken"]
            Write-Verbose ("Using Bearer authentication in {0}" -f $MyInvocation.MyCommand)
        }


        $LocalVarResult = Invoke-PSFApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "NetworkInterfaceGroupList" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

(Provider) Updates a Network Interface Group.

.DESCRIPTION

No description available.

.PARAMETER RegionName
The Region name

.PARAMETER AvailabilityZoneName
The Availability Zone name

.PARAMETER NetworkInterfaceGroupName
(Provider) The Network Interface Group name

.PARAMETER NetworkInterfaceGroupPatch
No description available.

.PARAMETER XRequestID
The Request ID supplied with the request, used to perform operations idempotently.

.PARAMETER Authorization
Access token (in JWT format) required to use any API endpoint.

.PARAMETER XCorrelationID
The Correlation ID provided will be added to log messages and can be used for support. The same Correlation ID may be used for separate requests, to track a higher level workflow.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Operation
#>
function Update-PSFNetworkInterfaceGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${RegionName},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AvailabilityZoneName},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${NetworkInterfaceGroupName},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${NetworkInterfaceGroupPatch},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XRequestID},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Authorization},
        [Parameter(Position = 6, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${XCorrelationID},
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Update-PSFNetworkInterfaceGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-PSFConfiguration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')

        $LocalVarUri = '/regions/{region_name}/availability-zones/{availability_zone_name}/network-interface-groups/{network_interface_group_name}'
        if (!$RegionName) {
            throw "Error! The required parameter `RegionName` missing when calling updateNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{region_name}', [System.Web.HTTPUtility]::UrlEncode($RegionName))
        if (!$AvailabilityZoneName) {
            throw "Error! The required parameter `AvailabilityZoneName` missing when calling updateNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{availability_zone_name}', [System.Web.HTTPUtility]::UrlEncode($AvailabilityZoneName))
        if (!$NetworkInterfaceGroupName) {
            throw "Error! The required parameter `NetworkInterfaceGroupName` missing when calling updateNetworkInterfaceGroup."
        }
        $LocalVarUri = $LocalVarUri.replace('{network_interface_group_name}', [System.Web.HTTPUtility]::UrlEncode($NetworkInterfaceGroupName))

        if ($XRequestID) {
            $LocalVarHeaderParameters['X-Request-ID'] = $XRequestID
        }

        if ($Authorization) {
            $LocalVarHeaderParameters['Authorization'] = $Authorization
        }

        if ($XCorrelationID) {
            $LocalVarHeaderParameters['X-Correlation-ID'] = $XCorrelationID
        }

        if (!$NetworkInterfaceGroupPatch) {
            throw "Error! The required parameter `NetworkInterfaceGroupPatch` missing when calling updateNetworkInterfaceGroup."
        }

        $LocalVarBodyParameter = $NetworkInterfaceGroupPatch | ConvertTo-Json -Depth 100

        if ($Configuration["AccessToken"]) {
            $LocalVarHeaderParameters['Authorization'] = "Bearer " + $Configuration["AccessToken"]
            Write-Verbose ("Using Bearer authentication in {0}" -f $MyInvocation.MyCommand)
        }


        $LocalVarResult = Invoke-PSFApiClient -Method 'PATCH' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Operation" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

